---
title: RIF and PMB combination
output: 
  md_document:
      fig_width: 7
      fig_height: 5
---

# Background 

We looked for combination therapies of neglected and misused antibiotics.
Rifampin and polymyxin B combination stood out as a promising approach against
scpectrum of clinical isolates.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, dpi=300)
knitr::opts_knit$set(global.par = TRUE)
library('data.table')
library('tidyverse')
library('DT')
library('cowplot')
library('BIGL')
library('drc')

devtools::document('input/r')
suppressMessages(devtools::load_all('input/r'))

options(datatable.print.nrows=20)

theme_set(theme_html())
update_geom_defaults("point", list(size = 0.9))
update_geom_defaults("line", list(size = 0.5))
.text_size = 3
.point_size = 2
.facet_size = 8
theme_update(
  #legend.position = "bottom",
  strip.text.y = element_text(size = 8)
)
```

# Combinations

We studied the potential of the rifampicin-polymyxin B combination against
intra- and extracellular forms of bacteria: three _P. aeruginosa_ strains, 
two clinical isolates of _A. baumannii_, _E. cloacae_, and _K. pneumoniae_.


```{r}
dat = readRDS('../analysis/data/r_obj/pmb-rif_all-clean.rds')
dat[, effect := round(effect, 3)]

# incomplete data interferes with surface analysis methods
dat = dat[!(cond=='intra' & strain=='ATCC27853' &
  !(c1 %in% c(0, 0.0016, 0.016, 0.048, 0.16, 0.48, 
      4.8, 16, 48, 160, 480, 1600) &
   c2 %in% c(0, 0.0004, 0.003, 0.004, 0.012, 0.03, 
     0.12, 0.3, 1, 1.2, 3, 4, 30, 40, 60, 200)))
]
# arrive at informative and uniform concentration range
dat = dat[(d1 %between% c(0.003, 100) | d1==0) & (d2 %between% c(0.003, 100) | d2==0)]

dat[is.na(effect), effect := -4.5]

# Response surface analysis
# rs = getRS(dat, 'rs')

```


# Dose Response And pH

```{r}
theme_set(theme_pdf())

sub = subset(dat, strain == 'ATCC27853' & (d1 == 0 | d2 == 0))

p1 = function() pltDR(effect ~ c1, subset(sub, c2==0), xlab = 'RIF, mg/L', zero=30)
p2 = function() pltDR(effect ~ c2, subset(sub, c1==0), col='orange', xlab = 'PMB, mg/L')

# pH
foo = fread("input/dat/raw/growth_and_pH.tsv")

foo = foo[time_h >= 0 & overnight_medium == 'pH7.4', .(
  od = gmu(od620),
  od.ci = gci(od620),
  ph = mean(pH),
  ph.ci = ci(pH)
  ), .(growth_medium, time_h)]


p0 = foo %>% 
  mutate(
    growth_medium = relevel(factor(growth_medium), 'pH7.4'),
    time_h = ifelse(time_h > 20, 20, time_h),
    NULL
    ) %>% 
  ggplot(aes(time_h, od, shape = growth_medium)) +
  scale_x_continuous(breaks = c(0, 5, 10, 20), labels = c(seq(0, 10, 5), 24), limits = c(0, 20)) +
  scale_shape_manual(name = '', values = c(19, 22, 15), labels = c('pH 7.4', 'pH 5.5',
      'pH 5.5 buffered')) +
  theme(legend.position = 'top')

p3 = p0 + 
  scale_y_continuous(trans='log2', breaks = c(0.001, 0.01, 0.1, 1), limits = c(0.001, 10)) + 
  geom_point(size=.point_size, col='grey20') +
  geom_pointrange(aes(ymin = od*od.ci, ymax = od/od.ci)) +
  geom_line(col='grey20') +
  labs(x = 'Time, h', y = expression('OD'[620]))

p4 = p0 %+% aes(y = ph) + 
  scale_y_continuous(position = 'right') +
  geom_point(size=.point_size, col=cbPalette[3]) +
  geom_line(col=cbPalette[3]) +
  geom_pointrange(aes(ymin = ph-ph.ci, ymax = ph + ph.ci), col=cbPalette[3]) +
  theme(legend.position = 'none',
    axis.title.y.right=element_text(color = cbPalette[3]),
    axis.text.y.right=element_text(color = cbPalette[3]),
    axis.ticks.y.right=element_line(color = cbPalette[3])
  ) +
  labs(x = '', y = 'pH')

aligned = align_plots(p3, p4, align = 'hv', axis = 'tblr')

plot_grid(
  ggdraw(p1), ggdraw(p2), ggdraw(aligned[[1]]) + draw_plot(aligned[[2]]), labels = 'AUTO', align = 'v'
)

# ggsave('output/fig/SFig_monotherapy_dose-response_and_pH.png', width=10, height=9)
```


# Reverse Genetics Screen

To account for the synergy in molecular terms—beyond a nonspecific increase in membrane permeability by polymyxin B—we turned to chemical genetics [Brochado and Typas, 2013](https://doi.org/10.1016/j.mib.2013.01.008). Working with ordered PA14 transposon library [Liberati et al., 2006](https://doi.org/10.1073/pnas.0511100103), we derived a growth measure for monotherapies and combinations using colony opacity [Kritikos et al., 2017](https://doi.org/10.1038/nmicrobiol.2017.14). To account for plate-to-plate variation, the opacity was multiplicatively corrected. This results in zero-centering of the Bliss scores, which were derived next. The significance of difference from zero Bliss score, for any mutant, was estimated by a T-test (5 biological replicates) and corrected for multiple testing (Benjamini-Hochberg).

```{r}
dat = loadIrisFiles("input/dat/raw/iris_files") %>% 
  addIrisVars() %>% 
  # Manual curation by visual inspection of images
  remBadPlates() %>% 
  flagBadColonies() %>% 
  turnBadColoniesToNAs() %>% 
  # Automatic curation by numbers
  setMisdetectedColoniesToNAs() %>%   # colonies missing from 60% of plates
  # plate-to-plate correction, brings plate opacities to same median
  correctOpacityForPlates()

rep.correlations = getPairwiseReplicateCorrelations(dat)
candidate.files.to.kick.out = getCandidateFilesToKickOut(rep.correlations)
candidate.files.to.kick.out[ratio.discordant.vs.all==1, filename]
# [1] "LBpH5.5-Rifampicin16Polymyxin2-015.JPG.iris"

# Fitness ----------------------------------------
condition.vs.control = long2wide(dat)  # also average controls using median
#remember: opacity was replaced by the corrected opacity
condition.vs.control[,f.condition:=opacity/control.median]
# dim(condition.vs.control[is.na(f.condition)])[1] / dim(condition.vs.control)[1]
# [1] 0.02289894  #2.2% of fitness values are NA

# Epsilon ----------------------------------------
drug.merge = getEpsilons(condition.vs.control)

drug.merge = addAnnotation(drug.merge)
drug.merge = tTest(drug.merge)
chem.gen.res = getTTestResults(drug.merge) %>% 
  correctForMultipleTesting()
```

```{r revgen-volc}
tmp = chem.gen.res %>% 
  mutate(t.test.q.value = ifelse(t.test.q.value < 0.001, 0.001,
      t.test.q.value)) %>% 
  mutate(showname = ifelse(
      (t.test.q.value < 0.05 & gene.name != '') | t.test.q.value < 0.01 ,
      T, F)) 

(p0 = filter(tmp, media == 'LB') %>%  
  {
  ggplot(., aes(epsilon.median.mutant.condition, -log10(t.test.q.value), col = t.test.q.value < 0.05)) +
  geom_point(size = 2.5) +
  scale_color_manual(values = c('grey70', 'grey20')) +
  ggrepel::geom_text_repel(data= . %>% .[(showname)], size = 6,
    aes(label=gene.name.to.show), box.padding=0.75, seed=3) +
  lims(x = c(-0.8, 0.6)) +
  labs(x = 'Shift in Bliss score', y = expression('log'[10]*'(p-value)')) +
  theme(aspect.ratio = 1, legend.position = 'none')

})

# ggsave('output/fig/ChemGen_LB.svg', width=5, height=5)

p0 %+% filter(tmp, media == 'LBpH5.5')
# ggsave('output/fig/ChemGen_LBpH5.5.svg', width=5, height=5)
```

```{r revgen-venn}
getGenes = function (dat) {
  out = list()
  for(i in unique(dat$media))
    out[[i]] = unique(dat[t.test.q.value < 0.05 & media == i], by='locus') %>%
      .[, (gene.name.to.show)]
  return(out)
}

foo = getGenes(chem.gen.res)
vtable = gplots::venn(foo)
```

# Enrichment analysis

With the following, we bring some biological knowledge into the analysis. This
will get us at the level of processes/compartments as opposed to individual
genes. We will focus on LB beacuse we have more data from there which is also
more reliable (75% of the unique hits come from LB; there is less variance). In
addition, our results suggest, the effect of pH on synergy is questionable in
PA14.


We did Gene Set Enrichment Analysis (GSEA) using GO terms from [pseudomonas.com
website](https://www.pseudomonas.com/) and Kologorov-Smirnov testing for
statistical significance estimation. Although most common approach, it has been
critizised for example
[here](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3134237/). 



```{r topGO}
library('topGO')
tab = getTopGO(chem.gen.res)

# cell components
tab[['CC']][1:10, c('GO.ID', 'Term', 'raw.p.value')] %>% 
  mutate(raw.p.value = round(as.numeric(raw.p.value), 4))

# biological processes
tab[['BP']][1:10, c('GO.ID', 'Term', 'raw.p.value')] %>% 
  mutate(raw.p.value = round(as.numeric(raw.p.value), 4))
```

# Protein-protein interaction network

Protein-protein interaction (PPI) analysis using impressive STRING database.
There was no data on PA14, so we will use PAO1 data to build and analyse the
network onto which we then map PA14 orthologs. 

1. The green nodes are more central and seem to be enriched in regulatory genes; 2. Yellow nodes (froming a group, but maiA seems to belong to it though does not have direct interactions with group members) seem to be related to signal transduction from membrane to the regulatory genes (green)
3. Light blue nodes are mostly related to metabolism, among them, those in orange-background-group have more membrane related terms than the blue nodes in blue background. 
4. Orange nodes (icmP, 56840, 47260) have to do with electron transfer


```{r ppi, fig.width=10, fig.cap='**FIGURE 4. Protein-protein interaction network analysis of candidate genes.** Clustering of hit proteins based on their interactions reported in various sources and assembled in STRING database.'}
library(igraph)
library(stringr)

hits = addAnnotation(chem.gen.res[t.test.q.value < 0.05, .(colony)])
hit_list = unique(hits[PAO1.ortholog != '', PAO1.ortholog])

# bring in the interactome
string_11_pa = 'input/dat/raw/pao1_ppi_stringDB_287.protein.links.v11.0.txt' %>% 
  fread() %>% 
  .[, `:=` (
    combined_score = combined_score/1000,
    #strip / trim species ID
    protein1 = gsub("287.DR97_", "PA", protein1, fixed=TRUE),
    protein2 = gsub("287.DR97_", "PA", protein2, fixed=TRUE)
  )]

# create an igraph object
pa_ppi = graph.data.frame(string_11_pa, directed = FALSE)
# summary(pa_ppi)
V(pa_ppi)$degree = degree(pa_ppi)

# overwrite the fixed igraph object
pa_ppi = pa_ppi_simple

# extract network for all the hits in the provided list
hit_ppi = induced.subgraph(pa_ppi, which(V(pa_ppi)$name %in% hit_list))

# store degree on the network (main hit network)
V(hit_ppi)$degree = degree(hit_ppi)

# Replace the PAO1 genes with corresponding PA14 ones
lookup = unique(hits[, .(PAO1.ortholog, gene=gene.name.to.show)], by='PAO1.ortholog')
V(hit_ppi)$name = left_join(data.table(PAO1.ortholog=V(hit_ppi)$name), lookup)[, gene]

# The layout is not deterministic - produces different configurations every time
# Saving the layout in l allows us to get the exact same result multiple times
# which can be helpful if you want to plot the time evolution of a graph,
# or different relationships – and want nodes to stay in the same place in multiple plots
l <- layout_with_kk(hit_ppi)
plot(hit_ppi, layout=l)
plot(hit_ppi, layout=layout_with_lgl(hit_ppi))
# 
# # Let’s take a look at all available layouts in igraph: 
# layouts <- grep("^layout_", ls("package:igraph"), value=TRUE)[-1]
# 
# # Remove layouts that do not apply to our graph.
# layouts <- layouts[!grepl("bipartite|merge|norm|sugiyama|tree", layouts)]
# par(mfrow=c(4,4), mar=c(1,1,1,1))
# for (layout in layouts) {
# print(layout)
# l <- do.call(layout, list(hit_ppi))
# plot(hit_ppi, edge.arrow.mode=0, layout=l, main=layout)
# }
# 
# hs <- hub_score(hit_ppi, weights=NA)$vector
# as <- authority_score(hit_ppi, weights=NA)$vector
# 
# par(mfrow=c(1,2))
# plot(hit_ppi, vertex.size=hs*500, main="Hubs")
# plot(hit_ppi, vertex.size=as*300, main="Authorities")
# dev.off()

# extract edge list from igraph with weights
hit_ppi_400_list = as.data.frame(cbind( get.edgelist(hit_ppi_400) , E(hit_ppi_400)$combined_score ))

# to round the weight values to 3 decimal places:
# as.numeric.factor <- function(x) {as.numeric(levels(x))[x]}
#hit_ppi_400_list <- as.data.frame(cbind( get.edgelist(hit_ppi_400) #,round(E(hit_ppi_400)$combined_score, 3 )))

# rename columns
names(hit_ppi_400_list)[names(hit_ppi_400_list) == 'V1'] = 'from'
names(hit_ppi_400_list)[names(hit_ppi_400_list) == 'V2'] = 'to'
names(hit_ppi_400_list)[names(hit_ppi_400_list) == 'V3'] = 'weight'

# write graph
# write.graph(hit_ppi_400,"hit_ppi_400_net.txt",format="edgelist")

# write the edgelist data frames
# network_list - unfiltered net
# write.table(hit_ppi_400_list, file="hit_ppi_400_list_10-07-2019.txt", row.names = F, quote = FALSE, sep="\t")

#plot(hit_ppi_400, edge.width=E(hit_ppi_400)$combined_score, vertex.size=1, vertex.label=NA, layout=layout.fruchterman.reingold)

# in cytoscape annotate the network with cluster information
# as well as source data information


#---------------------------------------------------------------------------------------
# Communities
#---------------------------------------------------------------------------------------
# A number of algorithms aim to detect groups that consist of densely connected nodes
# with fewer connections across groups.

# Community detection based on edge betweenness (Newman-Girvan)
# High-betweenness edges are removed sequentially (recalculating at each step)
# and the best partitioning of the network is selected.
# pdf('output/pdf/graph.pdf', height=10, width=20)
par(mfrow=c(1, 2), mar=c(1,3,1,1), cex=0.6)
set.seed(3)
ceb = cluster_edge_betweenness(hit_ppi) 
dendPlot(ceb, mode="hclust")
#pdf('fig/ppi_cluster.pdf', width=5, height=5)
par(mfrow=c(1, 1), mar=c(1,3,1,1), cex=0.6)
plot(ceb, hit_ppi)
#dev.off()
# dev.off()

#ggsave('fig/cluster.svg', width=10, height=5)


# # # Let's examine the community detection igraph object:
# class(ceb)
# length(ceb)     # number of communities
# membership(ceb) # community membership for each node
# crossing(ceb, hit_ppi)   # boolean vector: TRUE for edges across communities
# # there seems to be a bug here - crossing expects communities but fails saying it requires a vector
# modularity(ceb) # how modular the graph partitioning is

# High modularity for a partitioning reflects dense connections within communities 
# and sparse connections across communities.

# Community detection based on propagating labels
# Assigns node labels, randomizes, and replaces each vertex's label with
# the label that appears most frequently among neighbors. Repeated until
# each vertex has the most common label of its neighbors.
# net.sym = hit_ppi
# clp <- cluster_label_prop(net.sym)
# plot(clp, net.sym)
# 
# # Community detection based on greedy optimization of modularity
# cfg <- cluster_fast_greedy(as.undirected(hit_ppi))
# plot(cfg, as.undirected(hit_ppi))
#  
# # We can also plot the communities without relying on their built-in plot:
# V(hit_ppi)$community <- cfg$membership
# colrs <- adjustcolor( c("gray50", "tomato", "gold", "yellowgreen"), alpha=.6)
# plot(hit_ppi, vertex.color=colrs[V(hit_ppi)$community])


#---------------------------------------------------------------------------------------
# K-core decomposition
#---------------------------------------------------------------------------------------
# The k-core is the maximal subgraph in which every node has degree of at least k
# This also means that the (k+1)-core will be a subgraph of the k-core.
# The result here gives the coreness of each vertex in the network.
# kc <- coreness(hit_ppi, mode="all")
# plot(hit_ppi, vertex.size=kc*6, vertex.label=kc, vertex.color=colrs[kc])

```


```{r}
# bp = pa14_go[Accession %in% bio_proc$GO.ID, 'Gene Name'] 
# setnames(bp, 'Gene Name', 'gene')
# 
# for(i in seq_along(ceb)) {
#   #print(ceb[[i]])
#   print(i)
#   print(pa14_go[pa14_go$"Gene Name" %in% ceb[[i]], 'GO Term'])
# }
# 
# # igraph groups, dirty fix for the name problem
# g = ceb[1:15]
# g[[1]][2] = paste0('PA14_', g[[1]][2])
# g[[2]][4] = paste0('PA14_', g[[2]][4])
# g[[3]][c(1:2, 4:11)] = paste0('PA14_', g[[3]][c(1:2, 4:11)])
# g[[4]][c(1:2, 4:6)] = paste0('PA14_', g[[4]][c(1:2, 4:6)])
# g[[6]][1] = paste0('PA14_', g[[6]][1])
# g[[7]][c(1, 3:4)] = paste0('PA14_', g[[7]][c(1, 3:4)])
# g[[8]][1] = paste0('PA14_', g[[8]][1])
# g[[9]][1] = paste0('PA14_', g[[9]][1])
# g[[10]][1:6] = paste0('PA14_', g[[10]][1:6])
# g[[11]][1] = paste0('PA14_', g[[11]][1])
# g[[13]][1] = paste0('PA14_', g[[13]][1])
# 
# cc_list = lapply(seq_along(g), function(x) {
#             pa14_go[Namespace=='cellular_component' &
#                     pa14_go$"Gene Name" %in% g[[x]], c('GO Term', 'Gene Name')]})
# 
# bp_list = lapply(seq_along(g), function(x) {
#             pa14_go[Namespace=='biological_process' &
#                     pa14_go$"Gene Name" %in% g[[x]], c('GO Term', 'Gene Name')]})
# 
```



# Screen Validation

We validate the sensitivity of identified candidate mutants in low
throughput and in liquid LB medium at pH 7.4. Instead of factorial (i.e.
checkerboard), we use a fixed ratio design [Tallarida et al
1997](https://doi.org/10.1016/s0024-3205(97)01030-8).

```{r}
dat = fread('input/dat/raw/pa14_mut_pmb_rif.csv') %>% 
  addDrugRatio() %>% 
  addAUC() %>% 
  addFitness() %>% 
  remDissimilarExperimentalConditions() %>% 
  addPA14MutAnnotation()

dat[, dose:= ifelse(cond_f %in% c('PMB', 'combo'), d1, d2)]
dat_lst  = split(dat, dat$mut)
fit = lapply(dat_lst, fitPA14MutDR, curveid = cond_f)

# Loewe response surface ------------------------------
# rs = getPa14RS(dat)

# We'll use a snapshot of results from 2021-01-02
rsl = readRDS('input/dat/rds/2020-01-02_rs_pa14.rds') %>% lapply(., function(x) x$rsl)
foo = lapply(rsl, function(x) summary(x$maxR)$totals) %>% rbindlist(idcol='mut')
# Mutant numbering is potential source of confusion; hence I assign here
# manually: wild-type is coded as mut 0, fitting of mut 28 failed
foo[, mut := c(0:27, 29:45)]  
arrange(foo, Syn) %>% print(20)

tmpFun = function (x) unique(dat[mut %in% x], by = 'gene')$gene
tmpFun(c(23, 31, 33))  # no synergy
tmpFun(c(1, 16, 29, 35))  # less synergy than wt
tmpFun(c(4, 5, 14, 19, 40, 45, 12))  # more synergy
```

```{r plt45mutPA14}
#svg('output/fig/SFig_45PA14MutDoseResponses.svg', 12, 16)
plt45PA14MutantDR()  # dose-responses
#dev.off()

#svg('output/fig/SFig_45PA14MutCompLoeweNull.svg', 12, 16)
# We'll use a snapshot of results from 2021-01-02
plt45PA14MutantComparisonToLoeweNull('2020-01-02_rs_pa14')
#dev.off()
```


# Time-kill

```{r}
dtk = fread('input/dat/raw/time-kill.csv') %>% 
  remNonCharcoal() %>% 
  addNewVariablesToTimeKill()

pltTimeKill(dtk)
#ggsave('output/fig/SFig_TimeKill.svg', width=15, height=5)

# Print out the concentrations used
unique(dtk[time_h > 0], by = c('broth', 'group')) %>% 
  .[, .(broth, group, d_1, d_2)] %>% 
  .[order(group)]
```
